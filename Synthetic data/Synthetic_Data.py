# -*- coding: utf-8 -*-
"""
Created on Mon Nov 26 11:54:05 2018

@author: obazgir
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import math
import keras
from sklearn.model_selection import train_test_split
from keras.models import Sequential
from sklearn.model_selection import KFold
from keras.layers import Dense ,  Dropout
from sklearn.ensemble import RandomForestRegressor
from sklearn.svm import SVR

from scipy.stats import pearsonr
import os
os.chdir('C:\\Users\\obazgir\\Desktop\\CMDS_IMAGES_NEW\\Dr.Ghosh')
from MDS_RR import MDS_RR
## Simulating the data

P = [20,50,100,200,400,800,1000,2000,4000]                                                                  # Number of features
Results_Dic = {} 
for p in P:

  
    COV_X = 0.5*np.random.random((p,p))
    COV_X = np.maximum( COV_X, COV_X.transpose())                                   # Generating covariance highly correlated covariance matrix    
    #COV_X = 0.7*np.ones((p,p))
    
    for i in range(p):
        if i - int(p/20) < 0:
            COV_X[i,0:i+int(p/20)] =  0.2*np.random.random(i+int(p/20)) + 0.5
        elif i+int(p/20) > p:
            COV_X[i,i-int(p/20):] =  0.2*np.random.random(abs(p-i+int(p/20))) + 0.5
        #else:
         #   COV_X[i,i-int(p/20):i+int(p/20)] =  0.2*np.random.random(int(p/10)) + 0.5
    COV_X =  np.maximum( COV_X, COV_X.transpose())         
    np.fill_diagonal(COV_X, 1)       
    COV_X = np.ones((p,p)) - COV_X
    Columns_PD = p*[None];  index_PD = p*[None]
    
    for i in range(p):
        Columns_PD[i] = "F" + str(i)
        index_PD[i]   = "F" + str(i)
    
    COV_X_PD = pd.DataFrame(data = COV_X, index = index_PD, columns = Columns_PD)
    Mu = np.repeat(0.3, p)   
    
    #%% Init MDS
    import Toolbox
    from Toolbox import two_d_eq, Assign_features_to_pixels,Random_Image_Gen,REFINED_Im_Gen
    from sklearn.manifold import MDS
    from sklearn.metrics.pairwise import euclidean_distances
    import pickle
    
    
    #%% MDS
    nn = math.ceil(np.sqrt(p)) 				     # Image dimension
    Nn = p 										 # Number of features 
    Euc_Dist = COV_X   			 # Making the Euclidean distance matrix symmetric
    
    
    embedding = MDS(n_components=2)										 # Reduce the dimensionality by MDS into 2 components
    mds_xy = embedding.fit_transform(COV_X)					 # Apply MDS			
    
    print(">>>> MDS dimensionality reduction is done")
    
    eq_xy = two_d_eq(mds_xy,Nn)
    Img = Assign_features_to_pixels(eq_xy,nn,verbose=1)					# Img is the none-overlapping coordinates generated by MDS
    
    
    
    Desc = Columns_PD					                                 # Drug descriptors name
    Dist = pd.DataFrame(data = Euc_Dist, columns = Desc, index = Desc)	# Generating a distance matrix which includes the Euclidean distance between each and every descriptor
    data = (Desc, Dist, Img	)  											# Preparing the hill climbing inputs
    
    with open("Init_Synth"+str(p)+".pickle", 'wb') as f:					# The hill climbing input is a pickle, therefore everything is saved as a pickle to be loaded by the hill climbing
        pickle.dump(data, f)